/**
 * Generated by orval v7.7.0 üç∫
 * Do not edit manually.
 * xcroll REST API
 * Welcome to xcroll Rest API
 * OpenAPI spec version: 1.0.0
 */
import { useMutation, useQuery } from "@tanstack/react-query";
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query";

import type {
  ChangePassword,
  CommentListParams,
  EmailCheck,
  EmailSend,
  GetAccessToken,
  InputPoint,
  Jwt,
  LikeHistory,
  LikeHistoryListParams,
  PaginatedLikeHistoryList,
  PaginatedUserCommentsList,
  PaginatedUserList,
  PaginatedUserSearchHistoryList,
  PaginatedUserWatchHistoryList,
  PaginatedVideoDataList,
  PatchedLikeHistory,
  PatchedUserComments,
  PatchedUserSearchHistory,
  PatchedUserWatchHistory,
  PatchedVideoData,
  PointRetrieveParams,
  SearchHistoryListParams,
  SendEmailForFindPassword,
  Signup,
  TokenRefresh,
  User,
  UserComments,
  UserListParams,
  UserNameAuthRequest,
  UserPoint,
  UserPointHistory,
  UserReferralList,
  UserSearchHistory,
  UserValidationError,
  UserWatchHistory,
  UsernameCheck,
  ValidationError,
  VerifyCodeForFindPassword,
  VideoData,
  VideoDataListParams,
  WatchHistoryListParams,
} from "../model";

import { axiosInstance } from "../../../../../../src/api/instance";

// https://stackoverflow.com/questions/49579094/typescript-conditional-types-filter-out-readonly-properties-pick-only-requir/49579497#49579497
type IfEquals<X, Y, A = X, B = never> =
  (<T>() => T extends X ? 1 : 2) extends <T>() => T extends Y ? 1 : 2 ? A : B;

type WritableKeys<T> = {
  [P in keyof T]-?: IfEquals<
    { [Q in P]: T[P] },
    { -readonly [Q in P]: T[P] },
    P
  >;
}[keyof T];

type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (
  k: infer I,
) => void
  ? I
  : never;
type DistributeReadOnlyOverUnions<T> = T extends any ? NonReadonly<T> : never;

type Writable<T> = Pick<T, WritableKeys<T>>;
type NonReadonly<T> = [T] extends [UnionToIntersection<T>]
  ? {
      [P in keyof Writable<T>]: T[P] extends object
        ? NonReadonly<NonNullable<T[P]>>
        : T[P];
    }
  : DistributeReadOnlyOverUnions<T>;

/**
 * Î¶¨ÌîÑÎ†àÏãú ÌÜ†ÌÅ∞ÏùÑ Ïù¥Ïö©ÌïòÏó¨ ÏÉàÎ°úÏö¥ Ïï°ÏÑ∏Ïä§ ÌÜ†ÌÅ∞ÏùÑ Î∞úÍ∏âÌï©ÎãàÎã§.
 * @summary Get Access Token with Refresh Token
 */
export const authAuthenticateTokenRefreshCreate = (
  tokenRefresh: NonReadonly<TokenRefresh>,
  signal?: AbortSignal,
) => {
  return axiosInstance<GetAccessToken>({
    url: `/auth/authenticate/token/refresh`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: tokenRefresh,
    signal,
  });
};

export const getAuthAuthenticateTokenRefreshCreateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authAuthenticateTokenRefreshCreate>>,
    TError,
    { data: NonReadonly<TokenRefresh> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authAuthenticateTokenRefreshCreate>>,
  TError,
  { data: NonReadonly<TokenRefresh> },
  TContext
> => {
  const mutationKey = ["authAuthenticateTokenRefreshCreate"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authAuthenticateTokenRefreshCreate>>,
    { data: NonReadonly<TokenRefresh> }
  > = (props) => {
    const { data } = props ?? {};

    return authAuthenticateTokenRefreshCreate(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthAuthenticateTokenRefreshCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof authAuthenticateTokenRefreshCreate>>
>;
export type AuthAuthenticateTokenRefreshCreateMutationBody =
  NonReadonly<TokenRefresh>;
export type AuthAuthenticateTokenRefreshCreateMutationError = unknown;

/**
 * @summary Get Access Token with Refresh Token
 */
export const useAuthAuthenticateTokenRefreshCreate = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authAuthenticateTokenRefreshCreate>>,
    TError,
    { data: NonReadonly<TokenRefresh> },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof authAuthenticateTokenRefreshCreate>>,
  TError,
  { data: NonReadonly<TokenRefresh> },
  TContext
> => {
  const mutationOptions =
    getAuthAuthenticateTokenRefreshCreateMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Authenticate with username
 */
export const authAuthenticateUserIdCreate = (
  userNameAuthRequest: UserNameAuthRequest,
  signal?: AbortSignal,
) => {
  return axiosInstance<Jwt>({
    url: `/auth/authenticate/user-id`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: userNameAuthRequest,
    signal,
  });
};

export const getAuthAuthenticateUserIdCreateMutationOptions = <
  TError = ValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authAuthenticateUserIdCreate>>,
    TError,
    { data: UserNameAuthRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authAuthenticateUserIdCreate>>,
  TError,
  { data: UserNameAuthRequest },
  TContext
> => {
  const mutationKey = ["authAuthenticateUserIdCreate"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authAuthenticateUserIdCreate>>,
    { data: UserNameAuthRequest }
  > = (props) => {
    const { data } = props ?? {};

    return authAuthenticateUserIdCreate(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthAuthenticateUserIdCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof authAuthenticateUserIdCreate>>
>;
export type AuthAuthenticateUserIdCreateMutationBody = UserNameAuthRequest;
export type AuthAuthenticateUserIdCreateMutationError = ValidationError;

/**
 * @summary Authenticate with username
 */
export const useAuthAuthenticateUserIdCreate = <
  TError = ValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authAuthenticateUserIdCreate>>,
    TError,
    { data: UserNameAuthRequest },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof authAuthenticateUserIdCreate>>,
  TError,
  { data: UserNameAuthRequest },
  TContext
> => {
  const mutationOptions =
    getAuthAuthenticateUserIdCreateMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÌöåÏõêÍ∞ÄÏûÖ Ïãú ÏÇ¨Ïö©ÌïòÎ†§Í≥† ÌïòÎäî Ïù¥Î©îÏùºÎ°ú Î∞õÏùÄ Ïù∏Ï¶ùÎ≤àÌò∏Í∞Ä ÏïåÎßûÎäîÏßÄ ÌôïÏù∏Ìï©ÎãàÎã§.  
POST /auth/email-send ÌõÑÏóê ÏÇ¨Ïö©Ìï¥Ïïº Ìï©ÎãàÎã§.Ïù¥ÌõÑ POST /auth/signup APIÎ•º ÌÜµÌï¥ ÌöåÏõêÍ∞ÄÏûÖÏùÑ ÏßÑÌñâÌï©ÎãàÎã§.
 * @summary Ïù¥Î©îÏùº Ïù∏Ï¶ùÎ≤àÌò∏ ÌôïÏù∏
 */
export const authEmailCheckCreate = (
  emailCheck: EmailCheck,
  signal?: AbortSignal,
) => {
  return axiosInstance<void>({
    url: `/auth/email-check`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: emailCheck,
    signal,
  });
};

export const getAuthEmailCheckCreateMutationOptions = <
  TError = ValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authEmailCheckCreate>>,
    TError,
    { data: EmailCheck },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authEmailCheckCreate>>,
  TError,
  { data: EmailCheck },
  TContext
> => {
  const mutationKey = ["authEmailCheckCreate"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authEmailCheckCreate>>,
    { data: EmailCheck }
  > = (props) => {
    const { data } = props ?? {};

    return authEmailCheckCreate(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthEmailCheckCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof authEmailCheckCreate>>
>;
export type AuthEmailCheckCreateMutationBody = EmailCheck;
export type AuthEmailCheckCreateMutationError = ValidationError;

/**
 * @summary Ïù¥Î©îÏùº Ïù∏Ï¶ùÎ≤àÌò∏ ÌôïÏù∏
 */
export const useAuthEmailCheckCreate = <
  TError = ValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authEmailCheckCreate>>,
    TError,
    { data: EmailCheck },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof authEmailCheckCreate>>,
  TError,
  { data: EmailCheck },
  TContext
> => {
  const mutationOptions = getAuthEmailCheckCreateMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÌöåÏõêÍ∞ÄÏûÖ Ïãú ÏÇ¨Ïö©ÌïòÎ†§Í≥† ÌïòÎäî Ïù¥Î©îÏùºÏùÑ ÏûÖÎ†•ÌïòÏó¨ Ïù∏Ï¶ùÎ≤àÌò∏Î•º Ï†ÑÏÜ°Ìï©ÎãàÎã§.  
Ïù¥ÎØ∏ Í∞ÄÏûÖÎêú Ïù¥Î©îÏùºÏù∏ Í≤ΩÏö∞ ÏóêÎü¨Î•º Î∞òÌôòÌï©ÎãàÎã§.  
Ïù¥ÌõÑ POST /auth/email-check Î•º ÌÜµÌï¥ Ïù∏Ï¶ùÎ≤àÌò∏Î•º ÌôïÏù∏Ìï©ÎãàÎã§.
 * @summary Ïù¥Î©îÏùº Ï†ÑÏÜ°
 */
export const authEmailSendCreate = (
  emailSend: EmailSend,
  signal?: AbortSignal,
) => {
  return axiosInstance<void>({
    url: `/auth/email-send`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: emailSend,
    signal,
  });
};

export const getAuthEmailSendCreateMutationOptions = <
  TError = ValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authEmailSendCreate>>,
    TError,
    { data: EmailSend },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authEmailSendCreate>>,
  TError,
  { data: EmailSend },
  TContext
> => {
  const mutationKey = ["authEmailSendCreate"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authEmailSendCreate>>,
    { data: EmailSend }
  > = (props) => {
    const { data } = props ?? {};

    return authEmailSendCreate(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthEmailSendCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof authEmailSendCreate>>
>;
export type AuthEmailSendCreateMutationBody = EmailSend;
export type AuthEmailSendCreateMutationError = ValidationError;

/**
 * @summary Ïù¥Î©îÏùº Ï†ÑÏÜ°
 */
export const useAuthEmailSendCreate = <
  TError = ValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authEmailSendCreate>>,
    TError,
    { data: EmailSend },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof authEmailSendCreate>>,
  TError,
  { data: EmailSend },
  TContext
> => {
  const mutationOptions = getAuthEmailSendCreateMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÎπÑÎ∞ÄÎ≤àÌò∏Î•º Ï∞æÍ∏∞ ÏúÑÌï¥ POST /auth/find-password/email-send Î•º ÌÜµÌï¥ Î∞õÏùÄ Ïù∏Ï¶ùÎ≤àÌò∏Î•º Í≤ÄÏ¶ùÌï©ÎãàÎã§.  
Ïù∏Ï¶ùÎ≤àÌò∏Í∞Ä Ïú†Ìö®ÌïòÎ©¥ ÏÉàÎ°úÏö¥ ÎπÑÎ∞ÄÎ≤àÌò∏Î•º Ïù¥Î©îÏùºÎ°ú Î∞úÏÜ°Ìï©ÎãàÎã§.
 * @summary ÎπÑÎ∞ÄÎ≤àÌò∏ Ï∞æÍ∏∞Î•º ÏúÑÌïú Ïù∏Ï¶ùÎ≤àÌò∏ Í≤ÄÏ¶ù + ÏÉà ÎπÑÎ∞ÄÎ≤àÌò∏ Î∞úÏÜ°
 */
export const authFindPasswordEmailCheckCreate = (
  verifyCodeForFindPassword: VerifyCodeForFindPassword,
  signal?: AbortSignal,
) => {
  return axiosInstance<void>({
    url: `/auth/find-password/email-check`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: verifyCodeForFindPassword,
    signal,
  });
};

export const getAuthFindPasswordEmailCheckCreateMutationOptions = <
  TError = ValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authFindPasswordEmailCheckCreate>>,
    TError,
    { data: VerifyCodeForFindPassword },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authFindPasswordEmailCheckCreate>>,
  TError,
  { data: VerifyCodeForFindPassword },
  TContext
> => {
  const mutationKey = ["authFindPasswordEmailCheckCreate"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authFindPasswordEmailCheckCreate>>,
    { data: VerifyCodeForFindPassword }
  > = (props) => {
    const { data } = props ?? {};

    return authFindPasswordEmailCheckCreate(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthFindPasswordEmailCheckCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof authFindPasswordEmailCheckCreate>>
>;
export type AuthFindPasswordEmailCheckCreateMutationBody =
  VerifyCodeForFindPassword;
export type AuthFindPasswordEmailCheckCreateMutationError = ValidationError;

/**
 * @summary ÎπÑÎ∞ÄÎ≤àÌò∏ Ï∞æÍ∏∞Î•º ÏúÑÌïú Ïù∏Ï¶ùÎ≤àÌò∏ Í≤ÄÏ¶ù + ÏÉà ÎπÑÎ∞ÄÎ≤àÌò∏ Î∞úÏÜ°
 */
export const useAuthFindPasswordEmailCheckCreate = <
  TError = ValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authFindPasswordEmailCheckCreate>>,
    TError,
    { data: VerifyCodeForFindPassword },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof authFindPasswordEmailCheckCreate>>,
  TError,
  { data: VerifyCodeForFindPassword },
  TContext
> => {
  const mutationOptions =
    getAuthFindPasswordEmailCheckCreateMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÎπÑÎ∞ÄÎ≤àÌò∏Î•º Ï∞æÍ∏∞ ÏúÑÌï¥ Í∞ÄÏûÖÌïú Ïù¥Î©îÏùºÎ°ú Ïù∏Ï¶ùÎ≤àÌò∏Î•º Î∞úÏÜ°Ìï©ÎãàÎã§.
 * @summary ÎπÑÎ∞ÄÎ≤àÌò∏ Ï∞æÍ∏∞Î•º ÏúÑÌïú Ïù∏Ï¶ùÎ≤àÌò∏ Ïù¥Î©îÏùº Î∞úÏÜ°
 */
export const authFindPasswordEmailSendCreate = (
  sendEmailForFindPassword: SendEmailForFindPassword,
  signal?: AbortSignal,
) => {
  return axiosInstance<void>({
    url: `/auth/find-password/email-send`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: sendEmailForFindPassword,
    signal,
  });
};

export const getAuthFindPasswordEmailSendCreateMutationOptions = <
  TError = ValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authFindPasswordEmailSendCreate>>,
    TError,
    { data: SendEmailForFindPassword },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authFindPasswordEmailSendCreate>>,
  TError,
  { data: SendEmailForFindPassword },
  TContext
> => {
  const mutationKey = ["authFindPasswordEmailSendCreate"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authFindPasswordEmailSendCreate>>,
    { data: SendEmailForFindPassword }
  > = (props) => {
    const { data } = props ?? {};

    return authFindPasswordEmailSendCreate(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthFindPasswordEmailSendCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof authFindPasswordEmailSendCreate>>
>;
export type AuthFindPasswordEmailSendCreateMutationBody =
  SendEmailForFindPassword;
export type AuthFindPasswordEmailSendCreateMutationError = ValidationError;

/**
 * @summary ÎπÑÎ∞ÄÎ≤àÌò∏ Ï∞æÍ∏∞Î•º ÏúÑÌïú Ïù∏Ï¶ùÎ≤àÌò∏ Ïù¥Î©îÏùº Î∞úÏÜ°
 */
export const useAuthFindPasswordEmailSendCreate = <
  TError = ValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authFindPasswordEmailSendCreate>>,
    TError,
    { data: SendEmailForFindPassword },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof authFindPasswordEmailSendCreate>>,
  TError,
  { data: SendEmailForFindPassword },
  TContext
> => {
  const mutationOptions =
    getAuthFindPasswordEmailSendCreateMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÌöåÏõêÍ∞ÄÏûÖÏùÑ ÏßÑÌñâÌï©ÎãàÎã§.  
POST auth/email ÏãúÎ¶¨Ï¶à, POST /auth/username-check Î•º Ìïú Îí§Ïóê ÏÇ¨Ïö©Ìï¥Ïïº Ìï©ÎãàÎã§.
 * @summary ÌöåÏõêÍ∞ÄÏûÖ
 */
export const authSignupCreate = (signup: Signup, signal?: AbortSignal) => {
  return axiosInstance<Signup>({
    url: `/auth/signup`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: signup,
    signal,
  });
};

export const getAuthSignupCreateMutationOptions = <
  TError = ValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authSignupCreate>>,
    TError,
    { data: Signup },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authSignupCreate>>,
  TError,
  { data: Signup },
  TContext
> => {
  const mutationKey = ["authSignupCreate"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authSignupCreate>>,
    { data: Signup }
  > = (props) => {
    const { data } = props ?? {};

    return authSignupCreate(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthSignupCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof authSignupCreate>>
>;
export type AuthSignupCreateMutationBody = Signup;
export type AuthSignupCreateMutationError = ValidationError;

/**
 * @summary ÌöåÏõêÍ∞ÄÏûÖ
 */
export const useAuthSignupCreate = <
  TError = ValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authSignupCreate>>,
    TError,
    { data: Signup },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof authSignupCreate>>,
  TError,
  { data: Signup },
  TContext
> => {
  const mutationOptions = getAuthSignupCreateMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÌöåÏõêÍ∞ÄÏûÖ Ïãú ÏÇ¨Ïö©ÌïòÎ†§Í≥† ÌïòÎäî ÏïÑÏù¥ÎîîÎ•º ÏûÖÎ†•ÌïòÏó¨ ÏÇ¨Ïö© Í∞ÄÎä• Ïó¨Î∂ÄÎ•º ÌôïÏù∏Ìï©ÎãàÎã§.  
ÏÇ¨Ïö© Í∞ÄÎä•Ìïú ÏïÑÏù¥ÎîîÏù∏ Í≤ΩÏö∞ is_can: true Î•º Î∞òÌôòÌï©ÎãàÎã§.
 * @summary ÏïÑÏù¥Îîî Ï§ëÎ≥µ ÌôïÏù∏
 */
export const authUsernameCheckCreate = (
  usernameCheck: NonReadonly<UsernameCheck>,
  signal?: AbortSignal,
) => {
  return axiosInstance<UsernameCheck>({
    url: `/auth/username-check`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: usernameCheck,
    signal,
  });
};

export const getAuthUsernameCheckCreateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authUsernameCheckCreate>>,
    TError,
    { data: NonReadonly<UsernameCheck> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authUsernameCheckCreate>>,
  TError,
  { data: NonReadonly<UsernameCheck> },
  TContext
> => {
  const mutationKey = ["authUsernameCheckCreate"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authUsernameCheckCreate>>,
    { data: NonReadonly<UsernameCheck> }
  > = (props) => {
    const { data } = props ?? {};

    return authUsernameCheckCreate(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthUsernameCheckCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof authUsernameCheckCreate>>
>;
export type AuthUsernameCheckCreateMutationBody = NonReadonly<UsernameCheck>;
export type AuthUsernameCheckCreateMutationError = unknown;

/**
 * @summary ÏïÑÏù¥Îîî Ï§ëÎ≥µ ÌôïÏù∏
 */
export const useAuthUsernameCheckCreate = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authUsernameCheckCreate>>,
    TError,
    { data: NonReadonly<UsernameCheck> },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof authUsernameCheckCreate>>,
  TError,
  { data: NonReadonly<UsernameCheck> },
  TContext
> => {
  const mutationOptions = getAuthUsernameCheckCreateMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÎåìÍ∏Ä Î¶¨Ïä§Ìä∏Î•º Ï°∞ÌöåÌï©ÎãàÎã§.  
ÏÇ≠Ï†úÎêú ÎåìÍ∏ÄÏùÄ ÏÉÅÌô©Ïóê Îî∞Îùº content Í∞íÏù¥ 'ÏÇ≠Ï†úÎêú ÎåìÍ∏ÄÏûÖÎãàÎã§.'ÎùºÍ≥† ÌÖçÏä§Ìä∏ ÎåÄÏπò Ï≤òÎ¶¨Í∞Ä ÎêòÎ©∞ user Í∞íÏù¥ null Ï≤òÎ¶¨Îê©ÎãàÎã§.  
* ÎåÄÎåìÍ∏ÄÏïÑ ÏÇ≠Ï†úÎêêÏùÑ Í≤ΩÏö∞  
  * ÌÖçÏä§Ìä∏ ÎåÄÏπò Ï≤òÎ¶¨Í∞Ä Îê©ÎãàÎã§.  
* Î∂ÄÎ™® ÎåìÍ∏ÄÏù¥ ÏÇ≠Ï†úÎêêÏùÑ Í≤ΩÏö∞  
  * ÎåÄÎåìÍ∏ÄÏù¥ ÏóÜÏùÑ Í≤ΩÏö∞Ïóî Ï°∞ÌöåÎêòÏßÄ ÏïäÏäµÎãàÎã§.  
  * ÎåÄÎåìÍ∏ÄÏù¥ ÏûàÏùÑ Í≤ΩÏö∞ ÌÖçÏä§Ìä∏ ÎåÄÏπò Ï≤òÎ¶¨Í∞Ä Îê©ÎãàÎã§.  
filter Î°ú Ïú†Ï†Ä ÏïÑÏù¥Îîî, ÎπÑÎîîÏò§ ÏïÑÏù¥Îîî, ÎåÄÎåìÍ∏ÄÏù¥ ÏïÑÎãå ÎåìÍ∏Ä Ïú†Î¨¥, ÎåÄÎåìÍ∏ÄÏùò Î∂ÄÎ™® ÎåìÍ∏Ä id Î•º ÏÇ¨Ïö©Ìï† Ïàò ÏûàÏäµÎãàÎã§.  
* ÎåÄÎåìÍ∏Ä Ï°∞Ìöå Ïãú parent_id Î•º ÏÇ¨Ïö©Ìï©ÎãàÎã§.  
* Î∂ÄÎ™® ÎåìÍ∏Ä Ï°∞Ìöå Ïãú is_parent Î•º true Î°ú ÏßÄÏ†ïÌï©ÎãàÎã§.  
ÌäπÏ†ï ÎπÑÎîîÏò§Ïùò ÎåìÍ∏ÄÏùÑ Ï°∞ÌöåÌï† Îïê is_parent Î•º true Î°ú ÏßÄÏ†ïÌïòÍ≥† video_data id Î•º ÏÇ¨Ïö©Ìï©ÎãàÎã§.  
ordering ÏúºÎ°ú id, create_time ÏúºÎ°ú Ï†ïÎ†¨Ìï† Ïàò ÏûàÏäµÎãàÎã§. ÏµúÏã†Ïàú(ÎÇ¥Î¶ºÏ∞®Ïàú)ÏùÄ -create_time ÏûÖÎãàÎã§.
 * @summary Get Comments List
 */
export const commentList = (
  params?: CommentListParams,
  signal?: AbortSignal,
) => {
  return axiosInstance<PaginatedUserCommentsList>({
    url: `/comment`,
    method: "GET",
    params,
    signal,
  });
};

export const getCommentListQueryKey = (params?: CommentListParams) => {
  return [`/comment`, ...(params ? [params] : [])] as const;
};

export const getCommentListQueryOptions = <
  TData = Awaited<ReturnType<typeof commentList>>,
  TError = unknown,
>(
  params?: CommentListParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof commentList>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getCommentListQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof commentList>>> = ({
    signal,
  }) => commentList(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof commentList>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type CommentListQueryResult = NonNullable<
  Awaited<ReturnType<typeof commentList>>
>;
export type CommentListQueryError = unknown;

/**
 * @summary Get Comments List
 */

export function useCommentList<
  TData = Awaited<ReturnType<typeof commentList>>,
  TError = unknown,
>(
  params?: CommentListParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof commentList>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getCommentListQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÎåìÍ∏ÄÏùÑ ÏûëÏÑ±Ìï©ÎãàÎã§.  
ÎåÄÎåìÍ∏ÄÏùÑ ÏûëÏÑ±Ìï† Ïãú parent_id Î•º ÏßÄÏ†ïÌï©ÎãàÎã§.
 * @summary Create Comments
 */
export const commentCreate = (
  userComments: NonReadonly<UserComments>,
  signal?: AbortSignal,
) => {
  return axiosInstance<UserComments>({
    url: `/comment`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: userComments,
    signal,
  });
};

export const getCommentCreateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof commentCreate>>,
    TError,
    { data: NonReadonly<UserComments> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof commentCreate>>,
  TError,
  { data: NonReadonly<UserComments> },
  TContext
> => {
  const mutationKey = ["commentCreate"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof commentCreate>>,
    { data: NonReadonly<UserComments> }
  > = (props) => {
    const { data } = props ?? {};

    return commentCreate(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CommentCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof commentCreate>>
>;
export type CommentCreateMutationBody = NonReadonly<UserComments>;
export type CommentCreateMutationError = unknown;

/**
 * @summary Create Comments
 */
export const useCommentCreate = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof commentCreate>>,
    TError,
    { data: NonReadonly<UserComments> },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof commentCreate>>,
  TError,
  { data: NonReadonly<UserComments> },
  TContext
> => {
  const mutationOptions = getCommentCreateMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÌäπÏ†ï ÎåìÍ∏ÄÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary Get Comment Detail
 */
export const commentRetrieve = (id: number, signal?: AbortSignal) => {
  return axiosInstance<UserComments>({
    url: `/comment/${id}`,
    method: "GET",
    signal,
  });
};

export const getCommentRetrieveQueryKey = (id: number) => {
  return [`/comment/${id}`] as const;
};

export const getCommentRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof commentRetrieve>>,
  TError = unknown,
>(
  id: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof commentRetrieve>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getCommentRetrieveQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof commentRetrieve>>> = ({
    signal,
  }) => commentRetrieve(id, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof commentRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type CommentRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof commentRetrieve>>
>;
export type CommentRetrieveQueryError = unknown;

/**
 * @summary Get Comment Detail
 */

export function useCommentRetrieve<
  TData = Awaited<ReturnType<typeof commentRetrieve>>,
  TError = unknown,
>(
  id: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof commentRetrieve>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getCommentRetrieveQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÌäπÏ†ï ÎåìÍ∏ÄÏùÑ ÏàòÏ†ïÌï©ÎãàÎã§.  
Î≥∏Ïù∏Ïùò ÎåìÍ∏ÄÎßå ÏàòÏ†ïÌï† Ïàò ÏûàÏäµÎãàÎã§.
 * @summary Update Comment
 */
export const commentPartialUpdate = (
  id: number,
  patchedUserComments: NonReadonly<PatchedUserComments>,
) => {
  return axiosInstance<UserComments>({
    url: `/comment/${id}`,
    method: "PATCH",
    headers: { "Content-Type": "application/json" },
    data: patchedUserComments,
  });
};

export const getCommentPartialUpdateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof commentPartialUpdate>>,
    TError,
    { id: number; data: NonReadonly<PatchedUserComments> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof commentPartialUpdate>>,
  TError,
  { id: number; data: NonReadonly<PatchedUserComments> },
  TContext
> => {
  const mutationKey = ["commentPartialUpdate"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof commentPartialUpdate>>,
    { id: number; data: NonReadonly<PatchedUserComments> }
  > = (props) => {
    const { id, data } = props ?? {};

    return commentPartialUpdate(id, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CommentPartialUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof commentPartialUpdate>>
>;
export type CommentPartialUpdateMutationBody = NonReadonly<PatchedUserComments>;
export type CommentPartialUpdateMutationError = unknown;

/**
 * @summary Update Comment
 */
export const useCommentPartialUpdate = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof commentPartialUpdate>>,
    TError,
    { id: number; data: NonReadonly<PatchedUserComments> },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof commentPartialUpdate>>,
  TError,
  { id: number; data: NonReadonly<PatchedUserComments> },
  TContext
> => {
  const mutationOptions = getCommentPartialUpdateMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÌäπÏ†ï ÎåìÍ∏ÄÏùÑ ÏÇ≠Ï†úÌï©ÎãàÎã§.  
Î≥∏Ïù∏Ïùò ÎåìÍ∏ÄÎßå ÏÇ≠Ï†úÌï† Ïàò ÏûàÏäµÎãàÎã§.
 * @summary Delete Comment
 */
export const commentDestroy = (id: number) => {
  return axiosInstance<void>({ url: `/comment/${id}`, method: "DELETE" });
};

export const getCommentDestroyMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof commentDestroy>>,
    TError,
    { id: number },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof commentDestroy>>,
  TError,
  { id: number },
  TContext
> => {
  const mutationKey = ["commentDestroy"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof commentDestroy>>,
    { id: number }
  > = (props) => {
    const { id } = props ?? {};

    return commentDestroy(id);
  };

  return { mutationFn, ...mutationOptions };
};

export type CommentDestroyMutationResult = NonNullable<
  Awaited<ReturnType<typeof commentDestroy>>
>;

export type CommentDestroyMutationError = unknown;

/**
 * @summary Delete Comment
 */
export const useCommentDestroy = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof commentDestroy>>,
    TError,
    { id: number },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof commentDestroy>>,
  TError,
  { id: number },
  TContext
> => {
  const mutationOptions = getCommentDestroyMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Ï¢ãÏïÑÏöî Í∏∞Î°ù Î¶¨Ïä§Ìä∏Î•º Ï°∞ÌöåÌï©ÎãàÎã§.  
filter Î°ú Ïú†Ï†Ä ÏïÑÏù¥ÎîîÎ•º ÏÇ¨Ïö©Ìï† Ïàò ÏûàÏäµÎãàÎã§.  
ordering ÏúºÎ°ú id, create_time ÏúºÎ°ú Ï†ïÎ†¨Ìï† Ïàò ÏûàÏäµÎãàÎã§. ÏµúÏã†Ïàú(ÎÇ¥Î¶ºÏ∞®Ïàú)ÏùÄ -create_time ÏûÖÎãàÎã§.
 * @summary Get Like History List
 */
export const likeHistoryList = (
  params?: LikeHistoryListParams,
  signal?: AbortSignal,
) => {
  return axiosInstance<PaginatedLikeHistoryList>({
    url: `/like-history`,
    method: "GET",
    params,
    signal,
  });
};

export const getLikeHistoryListQueryKey = (params?: LikeHistoryListParams) => {
  return [`/like-history`, ...(params ? [params] : [])] as const;
};

export const getLikeHistoryListQueryOptions = <
  TData = Awaited<ReturnType<typeof likeHistoryList>>,
  TError = unknown,
>(
  params?: LikeHistoryListParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof likeHistoryList>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLikeHistoryListQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof likeHistoryList>>> = ({
    signal,
  }) => likeHistoryList(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof likeHistoryList>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type LikeHistoryListQueryResult = NonNullable<
  Awaited<ReturnType<typeof likeHistoryList>>
>;
export type LikeHistoryListQueryError = unknown;

/**
 * @summary Get Like History List
 */

export function useLikeHistoryList<
  TData = Awaited<ReturnType<typeof likeHistoryList>>,
  TError = unknown,
>(
  params?: LikeHistoryListParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof likeHistoryList>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getLikeHistoryListQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Ï¢ãÏïÑÏöî Í∏∞Î°ùÏùÑ ÏÉùÏÑ±Ìï©ÎãàÎã§.
 * @summary Create Like History
 */
export const likeHistoryCreate = (
  likeHistory: NonReadonly<LikeHistory>,
  signal?: AbortSignal,
) => {
  return axiosInstance<LikeHistory>({
    url: `/like-history`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: likeHistory,
    signal,
  });
};

export const getLikeHistoryCreateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof likeHistoryCreate>>,
    TError,
    { data: NonReadonly<LikeHistory> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof likeHistoryCreate>>,
  TError,
  { data: NonReadonly<LikeHistory> },
  TContext
> => {
  const mutationKey = ["likeHistoryCreate"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof likeHistoryCreate>>,
    { data: NonReadonly<LikeHistory> }
  > = (props) => {
    const { data } = props ?? {};

    return likeHistoryCreate(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type LikeHistoryCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof likeHistoryCreate>>
>;
export type LikeHistoryCreateMutationBody = NonReadonly<LikeHistory>;
export type LikeHistoryCreateMutationError = unknown;

/**
 * @summary Create Like History
 */
export const useLikeHistoryCreate = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof likeHistoryCreate>>,
    TError,
    { data: NonReadonly<LikeHistory> },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof likeHistoryCreate>>,
  TError,
  { data: NonReadonly<LikeHistory> },
  TContext
> => {
  const mutationOptions = getLikeHistoryCreateMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÌäπÏ†ï Ï¢ãÏïÑÏöî Í∏∞Î°ùÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary Get Like History Detail
 */
export const likeHistoryRetrieve = (id: number, signal?: AbortSignal) => {
  return axiosInstance<LikeHistory>({
    url: `/like-history/${id}`,
    method: "GET",
    signal,
  });
};

export const getLikeHistoryRetrieveQueryKey = (id: number) => {
  return [`/like-history/${id}`] as const;
};

export const getLikeHistoryRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof likeHistoryRetrieve>>,
  TError = unknown,
>(
  id: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof likeHistoryRetrieve>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLikeHistoryRetrieveQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof likeHistoryRetrieve>>
  > = ({ signal }) => likeHistoryRetrieve(id, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof likeHistoryRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type LikeHistoryRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof likeHistoryRetrieve>>
>;
export type LikeHistoryRetrieveQueryError = unknown;

/**
 * @summary Get Like History Detail
 */

export function useLikeHistoryRetrieve<
  TData = Awaited<ReturnType<typeof likeHistoryRetrieve>>,
  TError = unknown,
>(
  id: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof likeHistoryRetrieve>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getLikeHistoryRetrieveQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÌäπÏ†ï Ï¢ãÏïÑÏöî Í∏∞Î°ùÏùÑ ÏàòÏ†ïÌï©ÎãàÎã§.  
Î≥∏Ïù∏Ïùò Ï¢ãÏïÑÏöî Í∏∞Î°ùÎßå ÏàòÏ†ïÌï† Ïàò ÏûàÏäµÎãàÎã§.
 * @summary Update Like History
 */
export const likeHistoryPartialUpdate = (
  id: number,
  patchedLikeHistory: NonReadonly<PatchedLikeHistory>,
) => {
  return axiosInstance<LikeHistory>({
    url: `/like-history/${id}`,
    method: "PATCH",
    headers: { "Content-Type": "application/json" },
    data: patchedLikeHistory,
  });
};

export const getLikeHistoryPartialUpdateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof likeHistoryPartialUpdate>>,
    TError,
    { id: number; data: NonReadonly<PatchedLikeHistory> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof likeHistoryPartialUpdate>>,
  TError,
  { id: number; data: NonReadonly<PatchedLikeHistory> },
  TContext
> => {
  const mutationKey = ["likeHistoryPartialUpdate"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof likeHistoryPartialUpdate>>,
    { id: number; data: NonReadonly<PatchedLikeHistory> }
  > = (props) => {
    const { id, data } = props ?? {};

    return likeHistoryPartialUpdate(id, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type LikeHistoryPartialUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof likeHistoryPartialUpdate>>
>;
export type LikeHistoryPartialUpdateMutationBody =
  NonReadonly<PatchedLikeHistory>;
export type LikeHistoryPartialUpdateMutationError = unknown;

/**
 * @summary Update Like History
 */
export const useLikeHistoryPartialUpdate = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof likeHistoryPartialUpdate>>,
    TError,
    { id: number; data: NonReadonly<PatchedLikeHistory> },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof likeHistoryPartialUpdate>>,
  TError,
  { id: number; data: NonReadonly<PatchedLikeHistory> },
  TContext
> => {
  const mutationOptions = getLikeHistoryPartialUpdateMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÌäπÏ†ï Ï¢ãÏïÑÏöî Í∏∞Î°ùÏùÑ ÏÇ≠Ï†úÌï©ÎãàÎã§.  
Î≥∏Ïù∏Ïùò Ï¢ãÏïÑÏöî Í∏∞Î°ùÎßå ÏÇ≠Ï†úÌï† Ïàò ÏûàÏäµÎãàÎã§.
 * @summary Delete Like History
 */
export const likeHistoryDestroy = (id: number) => {
  return axiosInstance<void>({ url: `/like-history/${id}`, method: "DELETE" });
};

export const getLikeHistoryDestroyMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof likeHistoryDestroy>>,
    TError,
    { id: number },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof likeHistoryDestroy>>,
  TError,
  { id: number },
  TContext
> => {
  const mutationKey = ["likeHistoryDestroy"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof likeHistoryDestroy>>,
    { id: number }
  > = (props) => {
    const { id } = props ?? {};

    return likeHistoryDestroy(id);
  };

  return { mutationFn, ...mutationOptions };
};

export type LikeHistoryDestroyMutationResult = NonNullable<
  Awaited<ReturnType<typeof likeHistoryDestroy>>
>;

export type LikeHistoryDestroyMutationError = unknown;

/**
 * @summary Delete Like History
 */
export const useLikeHistoryDestroy = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof likeHistoryDestroy>>,
    TError,
    { id: number },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof likeHistoryDestroy>>,
  TError,
  { id: number },
  TContext
> => {
  const mutationOptions = getLikeHistoryDestroyMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÌäπÏ†ï ÏÉÅÌô©Ïóê Îî∞Î•∏ Ìè¨Ïù∏Ìä∏Î•º ÏûÖÍ∏àÌï©ÎãàÎã§.
 * @summary Ìè¨Ïù∏Ìä∏ ÏûÖÍ∏à
 */
export const pointCreate = (inputPoint: InputPoint, signal?: AbortSignal) => {
  return axiosInstance<void>({
    url: `/point`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: inputPoint,
    signal,
  });
};

export const getPointCreateMutationOptions = <
  TError = UserValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof pointCreate>>,
    TError,
    { data: InputPoint },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof pointCreate>>,
  TError,
  { data: InputPoint },
  TContext
> => {
  const mutationKey = ["pointCreate"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof pointCreate>>,
    { data: InputPoint }
  > = (props) => {
    const { data } = props ?? {};

    return pointCreate(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type PointCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof pointCreate>>
>;
export type PointCreateMutationBody = InputPoint;
export type PointCreateMutationError = UserValidationError;

/**
 * @summary Ìè¨Ïù∏Ìä∏ ÏûÖÍ∏à
 */
export const usePointCreate = <
  TError = UserValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof pointCreate>>,
    TError,
    { data: InputPoint },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof pointCreate>>,
  TError,
  { data: InputPoint },
  TContext
> => {
  const mutationOptions = getPointCreateMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÌòÑÏû¨ Ìè¨Ïù∏Ìä∏Î•º ÌôïÏù∏Ìï©ÎãàÎã§.  
**me** Path Parameter Î•º ÏÇ¨Ïö©ÌïòÎ©¥ ÌòÑÏû¨ Î°úÍ∑∏Ïù∏Ìïú Ïú†Ï†ÄÏùò Ìè¨Ïù∏Ìä∏Î•º ÌôïÏù∏Ìï† Ïàò ÏûàÏäµÎãàÎã§.  
Ïò§ÎäòÏûê, Ïñ¥Ï†úÏûê ÏñªÏùÄ Ìè¨Ïù∏Ìä∏Îäî /post ÏóêÏÑú ÌôïÏù∏Ìï† Ïàò ÏûàÏäµÎãàÎã§.
 * @summary ÎÇ¥ Ìè¨Ïù∏Ìä∏ Ï°∞Ìöå
 */
export const pointRetrieve = (
  id: string,
  params: PointRetrieveParams,
  signal?: AbortSignal,
) => {
  return axiosInstance<UserPoint>({
    url: `/point/${id}`,
    method: "GET",
    params,
    signal,
  });
};

export const getPointRetrieveQueryKey = (
  id: string,
  params: PointRetrieveParams,
) => {
  return [`/point/${id}`, ...(params ? [params] : [])] as const;
};

export const getPointRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof pointRetrieve>>,
  TError = UserValidationError,
>(
  id: string,
  params: PointRetrieveParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof pointRetrieve>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getPointRetrieveQueryKey(id, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof pointRetrieve>>> = ({
    signal,
  }) => pointRetrieve(id, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof pointRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type PointRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof pointRetrieve>>
>;
export type PointRetrieveQueryError = UserValidationError;

/**
 * @summary ÎÇ¥ Ìè¨Ïù∏Ìä∏ Ï°∞Ìöå
 */

export function usePointRetrieve<
  TData = Awaited<ReturnType<typeof pointRetrieve>>,
  TError = UserValidationError,
>(
  id: string,
  params: PointRetrieveParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof pointRetrieve>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getPointRetrieveQueryOptions(id, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Ïò§ÎäòÏûê, Ïñ¥Ï†úÏûê ÏñªÏùÄ Ìè¨Ïù∏Ìä∏ÏôÄ ÎçîÎ∂àÏñ¥ Ìè¨Ïù∏Ìä∏ Ïù¥Î†•ÏùÑ ÌôïÏù∏Ìï©ÎãàÎã§.
 **me** Path Parameter Î•º ÏÇ¨Ïö©ÌïòÎ©¥ ÌòÑÏû¨ Î°úÍ∑∏Ïù∏Ìïú Ïú†Ï†ÄÏùò Ìè¨Ïù∏Ìä∏ Ïù¥Î†•ÏùÑ ÌôïÏù∏Ìï† Ïàò ÏûàÏäµÎãàÎã§.
 * @summary Ìè¨Ïù∏Ìä∏ Ïù¥Î†•/ÏµúÍ∑º 2Ïùº ÏñªÏùÄ Ìè¨Ïù∏Ìä∏ Ï°∞Ìöå
 */
export const pointHistoryRetrieve = (id: string, signal?: AbortSignal) => {
  return axiosInstance<UserPointHistory>({
    url: `/point/history/${id}`,
    method: "GET",
    signal,
  });
};

export const getPointHistoryRetrieveQueryKey = (id: string) => {
  return [`/point/history/${id}`] as const;
};

export const getPointHistoryRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof pointHistoryRetrieve>>,
  TError = UserValidationError,
>(
  id: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof pointHistoryRetrieve>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getPointHistoryRetrieveQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof pointHistoryRetrieve>>
  > = ({ signal }) => pointHistoryRetrieve(id, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof pointHistoryRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type PointHistoryRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof pointHistoryRetrieve>>
>;
export type PointHistoryRetrieveQueryError = UserValidationError;

/**
 * @summary Ìè¨Ïù∏Ìä∏ Ïù¥Î†•/ÏµúÍ∑º 2Ïùº ÏñªÏùÄ Ìè¨Ïù∏Ìä∏ Ï°∞Ìöå
 */

export function usePointHistoryRetrieve<
  TData = Awaited<ReturnType<typeof pointHistoryRetrieve>>,
  TError = UserValidationError,
>(
  id: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof pointHistoryRetrieve>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getPointHistoryRetrieveQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Ïú†Ï†Ä Í≤ÄÏÉâ Í∏∞Î°ù Î¶¨Ïä§Ìä∏Î•º Ï°∞ÌöåÌï©ÎãàÎã§.  
filter Î°ú Ïú†Ï†Ä ÏïÑÏù¥ÎîîÎ•º ÏÇ¨Ïö©Ìï† Ïàò ÏûàÏäµÎãàÎã§.  
ordering ÏúºÎ°ú id, create_time ÏúºÎ°ú Ï†ïÎ†¨Ìï† Ïàò ÏûàÏäµÎãàÎã§. ÏµúÏã†Ïàú(ÎÇ¥Î¶ºÏ∞®Ïàú)ÏùÄ -create_time ÏûÖÎãàÎã§.
 * @summary Get User Search History List
 */
export const searchHistoryList = (
  params?: SearchHistoryListParams,
  signal?: AbortSignal,
) => {
  return axiosInstance<PaginatedUserSearchHistoryList>({
    url: `/search-history`,
    method: "GET",
    params,
    signal,
  });
};

export const getSearchHistoryListQueryKey = (
  params?: SearchHistoryListParams,
) => {
  return [`/search-history`, ...(params ? [params] : [])] as const;
};

export const getSearchHistoryListQueryOptions = <
  TData = Awaited<ReturnType<typeof searchHistoryList>>,
  TError = unknown,
>(
  params?: SearchHistoryListParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof searchHistoryList>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getSearchHistoryListQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof searchHistoryList>>
  > = ({ signal }) => searchHistoryList(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof searchHistoryList>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type SearchHistoryListQueryResult = NonNullable<
  Awaited<ReturnType<typeof searchHistoryList>>
>;
export type SearchHistoryListQueryError = unknown;

/**
 * @summary Get User Search History List
 */

export function useSearchHistoryList<
  TData = Awaited<ReturnType<typeof searchHistoryList>>,
  TError = unknown,
>(
  params?: SearchHistoryListParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof searchHistoryList>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getSearchHistoryListQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÌäπÏ†ï Ïú†Ï†ÄÏùò Í≤ÄÏÉâ Í∏∞Î°ùÏùÑ ÏÉùÏÑ±Ìï©ÎãàÎã§.
 * @summary Create User Search History
 */
export const searchHistoryCreate = (
  userSearchHistory: NonReadonly<UserSearchHistory>,
  signal?: AbortSignal,
) => {
  return axiosInstance<UserSearchHistory>({
    url: `/search-history`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: userSearchHistory,
    signal,
  });
};

export const getSearchHistoryCreateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof searchHistoryCreate>>,
    TError,
    { data: NonReadonly<UserSearchHistory> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof searchHistoryCreate>>,
  TError,
  { data: NonReadonly<UserSearchHistory> },
  TContext
> => {
  const mutationKey = ["searchHistoryCreate"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof searchHistoryCreate>>,
    { data: NonReadonly<UserSearchHistory> }
  > = (props) => {
    const { data } = props ?? {};

    return searchHistoryCreate(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SearchHistoryCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof searchHistoryCreate>>
>;
export type SearchHistoryCreateMutationBody = NonReadonly<UserSearchHistory>;
export type SearchHistoryCreateMutationError = unknown;

/**
 * @summary Create User Search History
 */
export const useSearchHistoryCreate = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof searchHistoryCreate>>,
    TError,
    { data: NonReadonly<UserSearchHistory> },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof searchHistoryCreate>>,
  TError,
  { data: NonReadonly<UserSearchHistory> },
  TContext
> => {
  const mutationOptions = getSearchHistoryCreateMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÌäπÏ†ï Ïú†Ï†ÄÏùò Í≤ÄÏÉâ Í∏∞Î°ùÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary Get User Search History Detail
 */
export const searchHistoryRetrieve = (id: number, signal?: AbortSignal) => {
  return axiosInstance<UserSearchHistory>({
    url: `/search-history/${id}`,
    method: "GET",
    signal,
  });
};

export const getSearchHistoryRetrieveQueryKey = (id: number) => {
  return [`/search-history/${id}`] as const;
};

export const getSearchHistoryRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof searchHistoryRetrieve>>,
  TError = unknown,
>(
  id: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof searchHistoryRetrieve>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getSearchHistoryRetrieveQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof searchHistoryRetrieve>>
  > = ({ signal }) => searchHistoryRetrieve(id, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof searchHistoryRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type SearchHistoryRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof searchHistoryRetrieve>>
>;
export type SearchHistoryRetrieveQueryError = unknown;

/**
 * @summary Get User Search History Detail
 */

export function useSearchHistoryRetrieve<
  TData = Awaited<ReturnType<typeof searchHistoryRetrieve>>,
  TError = unknown,
>(
  id: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof searchHistoryRetrieve>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getSearchHistoryRetrieveQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const searchHistoryUpdate = (
  id: number,
  userSearchHistory: NonReadonly<UserSearchHistory>,
) => {
  return axiosInstance<UserSearchHistory>({
    url: `/search-history/${id}`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: userSearchHistory,
  });
};

export const getSearchHistoryUpdateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof searchHistoryUpdate>>,
    TError,
    { id: number; data: NonReadonly<UserSearchHistory> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof searchHistoryUpdate>>,
  TError,
  { id: number; data: NonReadonly<UserSearchHistory> },
  TContext
> => {
  const mutationKey = ["searchHistoryUpdate"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof searchHistoryUpdate>>,
    { id: number; data: NonReadonly<UserSearchHistory> }
  > = (props) => {
    const { id, data } = props ?? {};

    return searchHistoryUpdate(id, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SearchHistoryUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof searchHistoryUpdate>>
>;
export type SearchHistoryUpdateMutationBody = NonReadonly<UserSearchHistory>;
export type SearchHistoryUpdateMutationError = unknown;

export const useSearchHistoryUpdate = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof searchHistoryUpdate>>,
    TError,
    { id: number; data: NonReadonly<UserSearchHistory> },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof searchHistoryUpdate>>,
  TError,
  { id: number; data: NonReadonly<UserSearchHistory> },
  TContext
> => {
  const mutationOptions = getSearchHistoryUpdateMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÌäπÏ†ï Ïú†Ï†ÄÏùò Í≤ÄÏÉâ Í∏∞Î°ùÏùÑ ÏàòÏ†ïÌï©ÎãàÎã§.  
Î≥∏Ïù∏Ïùò Í≤ÄÏÉâ Í∏∞Î°ùÎßå ÏàòÏ†ïÌï† Ïàò ÏûàÏäµÎãàÎã§.
 * @summary Update User Search History
 */
export const searchHistoryPartialUpdate = (
  id: number,
  patchedUserSearchHistory: NonReadonly<PatchedUserSearchHistory>,
) => {
  return axiosInstance<UserSearchHistory>({
    url: `/search-history/${id}`,
    method: "PATCH",
    headers: { "Content-Type": "application/json" },
    data: patchedUserSearchHistory,
  });
};

export const getSearchHistoryPartialUpdateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof searchHistoryPartialUpdate>>,
    TError,
    { id: number; data: NonReadonly<PatchedUserSearchHistory> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof searchHistoryPartialUpdate>>,
  TError,
  { id: number; data: NonReadonly<PatchedUserSearchHistory> },
  TContext
> => {
  const mutationKey = ["searchHistoryPartialUpdate"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof searchHistoryPartialUpdate>>,
    { id: number; data: NonReadonly<PatchedUserSearchHistory> }
  > = (props) => {
    const { id, data } = props ?? {};

    return searchHistoryPartialUpdate(id, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SearchHistoryPartialUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof searchHistoryPartialUpdate>>
>;
export type SearchHistoryPartialUpdateMutationBody =
  NonReadonly<PatchedUserSearchHistory>;
export type SearchHistoryPartialUpdateMutationError = unknown;

/**
 * @summary Update User Search History
 */
export const useSearchHistoryPartialUpdate = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof searchHistoryPartialUpdate>>,
    TError,
    { id: number; data: NonReadonly<PatchedUserSearchHistory> },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof searchHistoryPartialUpdate>>,
  TError,
  { id: number; data: NonReadonly<PatchedUserSearchHistory> },
  TContext
> => {
  const mutationOptions = getSearchHistoryPartialUpdateMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Ïú†Ï†Ä Î¶¨Ïä§Ìä∏Î•º Ï°∞ÌöåÌï©ÎãàÎã§.  
search Î°ú Ïú†Ï†Ä ÏïÑÏù¥ÎîîÎ•º Í≤ÄÏÉâÌï† Ïàò ÏûàÏäµÎãàÎã§.  
ordering ÏúºÎ°ú id, create_time ÏúºÎ°ú Ï†ïÎ†¨Ìï† Ïàò ÏûàÏäµÎãàÎã§. ÏµúÏã†Ïàú(ÎÇ¥Î¶ºÏ∞®Ïàú)ÏùÄ -create_time ÏûÖÎãàÎã§.
 * @summary Get User List
 */
export const userList = (params?: UserListParams, signal?: AbortSignal) => {
  return axiosInstance<PaginatedUserList>({
    url: `/user`,
    method: "GET",
    params,
    signal,
  });
};

export const getUserListQueryKey = (params?: UserListParams) => {
  return [`/user`, ...(params ? [params] : [])] as const;
};

export const getUserListQueryOptions = <
  TData = Awaited<ReturnType<typeof userList>>,
  TError = unknown,
>(
  params?: UserListParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof userList>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getUserListQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof userList>>> = ({
    signal,
  }) => userList(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof userList>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type UserListQueryResult = NonNullable<
  Awaited<ReturnType<typeof userList>>
>;
export type UserListQueryError = unknown;

/**
 * @summary Get User List
 */

export function useUserList<
  TData = Awaited<ReturnType<typeof userList>>,
  TError = unknown,
>(
  params?: UserListParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof userList>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getUserListQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÌäπÏ†ï Ïú†Ï†ÄÏùò ÏÉÅÏÑ∏ Ï†ïÎ≥¥Î•º Ï°∞ÌöåÌï©ÎãàÎã§.
 **me** Path Parameter Î•º ÏÇ¨Ïö©ÌïòÎ©¥ ÌòÑÏû¨ Î°úÍ∑∏Ïù∏Ìïú Ïú†Ï†ÄÏùò Ï†ïÎ≥¥Î•º Ï°∞ÌöåÌï† Ïàò ÏûàÏäµÎãàÎã§.
 * @summary Get User Detail
 */
export const userRetrieve = (id: string, signal?: AbortSignal) => {
  return axiosInstance<User>({ url: `/user/${id}`, method: "GET", signal });
};

export const getUserRetrieveQueryKey = (id: string) => {
  return [`/user/${id}`] as const;
};

export const getUserRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof userRetrieve>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof userRetrieve>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getUserRetrieveQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof userRetrieve>>> = ({
    signal,
  }) => userRetrieve(id, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof userRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type UserRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof userRetrieve>>
>;
export type UserRetrieveQueryError = unknown;

/**
 * @summary Get User Detail
 */

export function useUserRetrieve<
  TData = Awaited<ReturnType<typeof userRetrieve>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof userRetrieve>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getUserRetrieveQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÌöåÏõê ÌÉàÌá¥Ìï©ÎãàÎã§. **me** Path Parameter Î°ú Î≥∏Ïù∏Îßå Í∞ÄÎä•Ìï©ÎãàÎã§.
 * @summary ÌöåÏõê ÌÉàÌá¥
 */
export const userDestroy = (id: string) => {
  return axiosInstance<void>({ url: `/user/${id}`, method: "DELETE" });
};

export const getUserDestroyMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof userDestroy>>,
    TError,
    { id: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof userDestroy>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ["userDestroy"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof userDestroy>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {};

    return userDestroy(id);
  };

  return { mutationFn, ...mutationOptions };
};

export type UserDestroyMutationResult = NonNullable<
  Awaited<ReturnType<typeof userDestroy>>
>;

export type UserDestroyMutationError = unknown;

/**
 * @summary ÌöåÏõê ÌÉàÌá¥
 */
export const useUserDestroy = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof userDestroy>>,
    TError,
    { id: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof userDestroy>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getUserDestroyMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÎπÑÎ∞ÄÎ≤àÌò∏Î•º Î≥ÄÍ≤ΩÌï©ÎãàÎã§.  
Í∏∞Ï°¥ ÎπÑÎ∞ÄÎ≤àÌò∏ÏôÄ ÎçîÎ∂àÏñ¥ Ïã†Í∑ú ÎπÑÎ∞ÄÎ≤àÌò∏Î•º Í∞ôÏù¥ ÏûÖÎ†•Ìï¥Ïïº Ìï©ÎãàÎã§.
 * @summary ÎπÑÎ∞ÄÎ≤àÌò∏ Î≥ÄÍ≤Ω
 */
export const userChangePasswordCreate = (
  changePassword: ChangePassword,
  signal?: AbortSignal,
) => {
  return axiosInstance<void>({
    url: `/user/change-password`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: changePassword,
    signal,
  });
};

export const getUserChangePasswordCreateMutationOptions = <
  TError = UserValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof userChangePasswordCreate>>,
    TError,
    { data: ChangePassword },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof userChangePasswordCreate>>,
  TError,
  { data: ChangePassword },
  TContext
> => {
  const mutationKey = ["userChangePasswordCreate"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof userChangePasswordCreate>>,
    { data: ChangePassword }
  > = (props) => {
    const { data } = props ?? {};

    return userChangePasswordCreate(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UserChangePasswordCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof userChangePasswordCreate>>
>;
export type UserChangePasswordCreateMutationBody = ChangePassword;
export type UserChangePasswordCreateMutationError = UserValidationError;

/**
 * @summary ÎπÑÎ∞ÄÎ≤àÌò∏ Î≥ÄÍ≤Ω
 */
export const useUserChangePasswordCreate = <
  TError = UserValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof userChangePasswordCreate>>,
    TError,
    { data: ChangePassword },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof userChangePasswordCreate>>,
  TError,
  { data: ChangePassword },
  TContext
> => {
  const mutationOptions = getUserChangePasswordCreateMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÎÇ¥ Ï∂îÏ≤ú ÌöüÏàò Î¶¨Ïä§Ìä∏Î•º Ï°∞ÌöåÌï©ÎãàÎã§.
 **me** Path Parameter Î•º ÏÇ¨Ïö©ÌïòÎ©¥ ÌòÑÏû¨ Î°úÍ∑∏Ïù∏Ìïú Ïú†Ï†ÄÏùò Ï∂îÏ≤ú ÌöüÏàò Î¶¨Ïä§Ìä∏Î•º Ï°∞ÌöåÌï† Ïàò ÏûàÏäµÎãàÎã§.
 * @summary ÎÇ¥ Ï∂îÏ≤ú ÌöüÏàò Ï°∞Ìöå
 */
export const userReferralListRetrieve = (id: string, signal?: AbortSignal) => {
  return axiosInstance<UserReferralList>({
    url: `/user/referral-list/${id}`,
    method: "GET",
    signal,
  });
};

export const getUserReferralListRetrieveQueryKey = (id: string) => {
  return [`/user/referral-list/${id}`] as const;
};

export const getUserReferralListRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof userReferralListRetrieve>>,
  TError = UserValidationError,
>(
  id: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof userReferralListRetrieve>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getUserReferralListRetrieveQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof userReferralListRetrieve>>
  > = ({ signal }) => userReferralListRetrieve(id, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof userReferralListRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type UserReferralListRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof userReferralListRetrieve>>
>;
export type UserReferralListRetrieveQueryError = UserValidationError;

/**
 * @summary ÎÇ¥ Ï∂îÏ≤ú ÌöüÏàò Ï°∞Ìöå
 */

export function useUserReferralListRetrieve<
  TData = Awaited<ReturnType<typeof userReferralListRetrieve>>,
  TError = UserValidationError,
>(
  id: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof userReferralListRetrieve>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getUserReferralListRetrieveQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÎπÑÎîîÏò§ Î¶¨Ïä§Ìä∏Î•º Ï°∞ÌöåÌï©ÎãàÎã§.  
content_type ÏúºÎ°ú ÌïÑÌÑ∞ÎßÅ Í∞ÄÎä•Ìï©ÎãàÎã§.  
search Î°ú ÏòÅÏÉÅ Ïù¥Î¶Ñ, ÏòÅÏÉÅ ÏÑ§Î™ÖÏùÑ Í≤ÄÏÉâÌï† Ïàò ÏûàÏäµÎãàÎã§.  
ordering ÏúºÎ°ú id, create_time ÏúºÎ°ú Ï†ïÎ†¨Ìï† Ïàò ÏûàÏäµÎãàÎã§. ÏµúÏã†Ïàú(ÎÇ¥Î¶ºÏ∞®Ïàú)ÏùÄ -create_time ÏûÖÎãàÎã§.
 * @summary Get Video Data List
 */
export const videoDataList = (
  params?: VideoDataListParams,
  signal?: AbortSignal,
) => {
  return axiosInstance<PaginatedVideoDataList>({
    url: `/video-data`,
    method: "GET",
    params,
    signal,
  });
};

export const getVideoDataListQueryKey = (params?: VideoDataListParams) => {
  return [`/video-data`, ...(params ? [params] : [])] as const;
};

export const getVideoDataListQueryOptions = <
  TData = Awaited<ReturnType<typeof videoDataList>>,
  TError = unknown,
>(
  params?: VideoDataListParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof videoDataList>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getVideoDataListQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof videoDataList>>> = ({
    signal,
  }) => videoDataList(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof videoDataList>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type VideoDataListQueryResult = NonNullable<
  Awaited<ReturnType<typeof videoDataList>>
>;
export type VideoDataListQueryError = unknown;

/**
 * @summary Get Video Data List
 */

export function useVideoDataList<
  TData = Awaited<ReturnType<typeof videoDataList>>,
  TError = unknown,
>(
  params?: VideoDataListParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof videoDataList>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getVideoDataListQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏÉàÎ°úÏö¥ ÎπÑÎîîÏò§ Îç∞Ïù¥ÌÑ∞Î•º ÏÉùÏÑ±Ìï©ÎãàÎã§.
 * @summary Create Video Data
 */
export const videoDataCreate = (
  videoData: NonReadonly<VideoData>,
  signal?: AbortSignal,
) => {
  return axiosInstance<VideoData>({
    url: `/video-data`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: videoData,
    signal,
  });
};

export const getVideoDataCreateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof videoDataCreate>>,
    TError,
    { data: NonReadonly<VideoData> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof videoDataCreate>>,
  TError,
  { data: NonReadonly<VideoData> },
  TContext
> => {
  const mutationKey = ["videoDataCreate"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof videoDataCreate>>,
    { data: NonReadonly<VideoData> }
  > = (props) => {
    const { data } = props ?? {};

    return videoDataCreate(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type VideoDataCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof videoDataCreate>>
>;
export type VideoDataCreateMutationBody = NonReadonly<VideoData>;
export type VideoDataCreateMutationError = unknown;

/**
 * @summary Create Video Data
 */
export const useVideoDataCreate = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof videoDataCreate>>,
    TError,
    { data: NonReadonly<VideoData> },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof videoDataCreate>>,
  TError,
  { data: NonReadonly<VideoData> },
  TContext
> => {
  const mutationOptions = getVideoDataCreateMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÌäπÏ†ï ÎπÑÎîîÏò§Ïùò ÏÉÅÏÑ∏ Ï†ïÎ≥¥Î•º Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary Get Video Data Detail
 */
export const videoDataRetrieve = (id: number, signal?: AbortSignal) => {
  return axiosInstance<VideoData>({
    url: `/video-data/${id}`,
    method: "GET",
    signal,
  });
};

export const getVideoDataRetrieveQueryKey = (id: number) => {
  return [`/video-data/${id}`] as const;
};

export const getVideoDataRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof videoDataRetrieve>>,
  TError = unknown,
>(
  id: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof videoDataRetrieve>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getVideoDataRetrieveQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof videoDataRetrieve>>
  > = ({ signal }) => videoDataRetrieve(id, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof videoDataRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type VideoDataRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof videoDataRetrieve>>
>;
export type VideoDataRetrieveQueryError = unknown;

/**
 * @summary Get Video Data Detail
 */

export function useVideoDataRetrieve<
  TData = Awaited<ReturnType<typeof videoDataRetrieve>>,
  TError = unknown,
>(
  id: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof videoDataRetrieve>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getVideoDataRetrieveQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÌäπÏ†ï ÎπÑÎîîÏò§Ïùò Ï†ïÎ≥¥Î•º ÏàòÏ†ïÌï©ÎãàÎã§.
 * @summary Update Video Data
 */
export const videoDataPartialUpdate = (
  id: number,
  patchedVideoData: NonReadonly<PatchedVideoData>,
) => {
  return axiosInstance<VideoData>({
    url: `/video-data/${id}`,
    method: "PATCH",
    headers: { "Content-Type": "application/json" },
    data: patchedVideoData,
  });
};

export const getVideoDataPartialUpdateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof videoDataPartialUpdate>>,
    TError,
    { id: number; data: NonReadonly<PatchedVideoData> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof videoDataPartialUpdate>>,
  TError,
  { id: number; data: NonReadonly<PatchedVideoData> },
  TContext
> => {
  const mutationKey = ["videoDataPartialUpdate"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof videoDataPartialUpdate>>,
    { id: number; data: NonReadonly<PatchedVideoData> }
  > = (props) => {
    const { id, data } = props ?? {};

    return videoDataPartialUpdate(id, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type VideoDataPartialUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof videoDataPartialUpdate>>
>;
export type VideoDataPartialUpdateMutationBody = NonReadonly<PatchedVideoData>;
export type VideoDataPartialUpdateMutationError = unknown;

/**
 * @summary Update Video Data
 */
export const useVideoDataPartialUpdate = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof videoDataPartialUpdate>>,
    TError,
    { id: number; data: NonReadonly<PatchedVideoData> },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof videoDataPartialUpdate>>,
  TError,
  { id: number; data: NonReadonly<PatchedVideoData> },
  TContext
> => {
  const mutationOptions = getVideoDataPartialUpdateMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÌäπÏ†ï ÎπÑÎîîÏò§Î•º ÏÇ≠Ï†úÌï©ÎãàÎã§.  
ÎßàÏä§ÌÑ∞ Í≥ÑÏ†ïÎßå Í∞ÄÎä•Ìï©ÎãàÎã§.
 * @summary Delete Video Data
 */
export const videoDataDestroy = (id: number) => {
  return axiosInstance<void>({ url: `/video-data/${id}`, method: "DELETE" });
};

export const getVideoDataDestroyMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof videoDataDestroy>>,
    TError,
    { id: number },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof videoDataDestroy>>,
  TError,
  { id: number },
  TContext
> => {
  const mutationKey = ["videoDataDestroy"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof videoDataDestroy>>,
    { id: number }
  > = (props) => {
    const { id } = props ?? {};

    return videoDataDestroy(id);
  };

  return { mutationFn, ...mutationOptions };
};

export type VideoDataDestroyMutationResult = NonNullable<
  Awaited<ReturnType<typeof videoDataDestroy>>
>;

export type VideoDataDestroyMutationError = unknown;

/**
 * @summary Delete Video Data
 */
export const useVideoDataDestroy = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof videoDataDestroy>>,
    TError,
    { id: number },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof videoDataDestroy>>,
  TError,
  { id: number },
  TContext
> => {
  const mutationOptions = getVideoDataDestroyMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Ïú†Ï†Ä ÏãúÏ≤≠ Í∏∞Î°ù Î¶¨Ïä§Ìä∏Î•º Ï°∞ÌöåÌï©ÎãàÎã§.  
filter Î°ú Ïú†Ï†Ä ÏïÑÏù¥ÎîîÎ•º ÏÇ¨Ïö©Ìï† Ïàò ÏûàÏäµÎãàÎã§.  
ordering ÏúºÎ°ú id, create_time ÏúºÎ°ú Ï†ïÎ†¨Ìï† Ïàò ÏûàÏäµÎãàÎã§. ÏµúÏã†Ïàú(ÎÇ¥Î¶ºÏ∞®Ïàú)ÏùÄ -create_time ÏûÖÎãàÎã§.
 * @summary Get User Watch History List
 */
export const watchHistoryList = (
  params?: WatchHistoryListParams,
  signal?: AbortSignal,
) => {
  return axiosInstance<PaginatedUserWatchHistoryList>({
    url: `/watch-history`,
    method: "GET",
    params,
    signal,
  });
};

export const getWatchHistoryListQueryKey = (
  params?: WatchHistoryListParams,
) => {
  return [`/watch-history`, ...(params ? [params] : [])] as const;
};

export const getWatchHistoryListQueryOptions = <
  TData = Awaited<ReturnType<typeof watchHistoryList>>,
  TError = unknown,
>(
  params?: WatchHistoryListParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof watchHistoryList>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getWatchHistoryListQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof watchHistoryList>>
  > = ({ signal }) => watchHistoryList(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof watchHistoryList>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type WatchHistoryListQueryResult = NonNullable<
  Awaited<ReturnType<typeof watchHistoryList>>
>;
export type WatchHistoryListQueryError = unknown;

/**
 * @summary Get User Watch History List
 */

export function useWatchHistoryList<
  TData = Awaited<ReturnType<typeof watchHistoryList>>,
  TError = unknown,
>(
  params?: WatchHistoryListParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof watchHistoryList>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getWatchHistoryListQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÌäπÏ†ï Ïú†Ï†ÄÏùò ÏãúÏ≤≠ Í∏∞Î°ùÏùÑ ÏÉùÏÑ±Ìï©ÎãàÎã§.
 * @summary Create User Watch History
 */
export const watchHistoryCreate = (
  userWatchHistory: NonReadonly<UserWatchHistory>,
  signal?: AbortSignal,
) => {
  return axiosInstance<UserWatchHistory>({
    url: `/watch-history`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: userWatchHistory,
    signal,
  });
};

export const getWatchHistoryCreateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof watchHistoryCreate>>,
    TError,
    { data: NonReadonly<UserWatchHistory> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof watchHistoryCreate>>,
  TError,
  { data: NonReadonly<UserWatchHistory> },
  TContext
> => {
  const mutationKey = ["watchHistoryCreate"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof watchHistoryCreate>>,
    { data: NonReadonly<UserWatchHistory> }
  > = (props) => {
    const { data } = props ?? {};

    return watchHistoryCreate(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type WatchHistoryCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof watchHistoryCreate>>
>;
export type WatchHistoryCreateMutationBody = NonReadonly<UserWatchHistory>;
export type WatchHistoryCreateMutationError = unknown;

/**
 * @summary Create User Watch History
 */
export const useWatchHistoryCreate = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof watchHistoryCreate>>,
    TError,
    { data: NonReadonly<UserWatchHistory> },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof watchHistoryCreate>>,
  TError,
  { data: NonReadonly<UserWatchHistory> },
  TContext
> => {
  const mutationOptions = getWatchHistoryCreateMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÌäπÏ†ï Ïú†Ï†Ä ÏãúÏ≤≠ Í∏∞Î°ùÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary Get User Watch History Detail
 */
export const watchHistoryRetrieve = (id: number, signal?: AbortSignal) => {
  return axiosInstance<UserWatchHistory>({
    url: `/watch-history/${id}`,
    method: "GET",
    signal,
  });
};

export const getWatchHistoryRetrieveQueryKey = (id: number) => {
  return [`/watch-history/${id}`] as const;
};

export const getWatchHistoryRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof watchHistoryRetrieve>>,
  TError = unknown,
>(
  id: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof watchHistoryRetrieve>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getWatchHistoryRetrieveQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof watchHistoryRetrieve>>
  > = ({ signal }) => watchHistoryRetrieve(id, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof watchHistoryRetrieve>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type WatchHistoryRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof watchHistoryRetrieve>>
>;
export type WatchHistoryRetrieveQueryError = unknown;

/**
 * @summary Get User Watch History Detail
 */

export function useWatchHistoryRetrieve<
  TData = Awaited<ReturnType<typeof watchHistoryRetrieve>>,
  TError = unknown,
>(
  id: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof watchHistoryRetrieve>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getWatchHistoryRetrieveQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const watchHistoryUpdate = (
  id: number,
  userWatchHistory: NonReadonly<UserWatchHistory>,
) => {
  return axiosInstance<UserWatchHistory>({
    url: `/watch-history/${id}`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: userWatchHistory,
  });
};

export const getWatchHistoryUpdateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof watchHistoryUpdate>>,
    TError,
    { id: number; data: NonReadonly<UserWatchHistory> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof watchHistoryUpdate>>,
  TError,
  { id: number; data: NonReadonly<UserWatchHistory> },
  TContext
> => {
  const mutationKey = ["watchHistoryUpdate"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof watchHistoryUpdate>>,
    { id: number; data: NonReadonly<UserWatchHistory> }
  > = (props) => {
    const { id, data } = props ?? {};

    return watchHistoryUpdate(id, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type WatchHistoryUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof watchHistoryUpdate>>
>;
export type WatchHistoryUpdateMutationBody = NonReadonly<UserWatchHistory>;
export type WatchHistoryUpdateMutationError = unknown;

export const useWatchHistoryUpdate = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof watchHistoryUpdate>>,
    TError,
    { id: number; data: NonReadonly<UserWatchHistory> },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof watchHistoryUpdate>>,
  TError,
  { id: number; data: NonReadonly<UserWatchHistory> },
  TContext
> => {
  const mutationOptions = getWatchHistoryUpdateMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÌäπÏ†ï Ïú†Ï†Ä ÏãúÏ≤≠ Í∏∞Î°ùÏùÑ ÏàòÏ†ïÌï©ÎãàÎã§.  
Î≥∏Ïù∏Ïùò ÏãúÏ≤≠ Í∏∞Î°ùÎßå ÏàòÏ†ïÌï† Ïàò ÏûàÏäµÎãàÎã§.
 * @summary Update User Watch History
 */
export const watchHistoryPartialUpdate = (
  id: number,
  patchedUserWatchHistory: NonReadonly<PatchedUserWatchHistory>,
) => {
  return axiosInstance<UserWatchHistory>({
    url: `/watch-history/${id}`,
    method: "PATCH",
    headers: { "Content-Type": "application/json" },
    data: patchedUserWatchHistory,
  });
};

export const getWatchHistoryPartialUpdateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof watchHistoryPartialUpdate>>,
    TError,
    { id: number; data: NonReadonly<PatchedUserWatchHistory> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof watchHistoryPartialUpdate>>,
  TError,
  { id: number; data: NonReadonly<PatchedUserWatchHistory> },
  TContext
> => {
  const mutationKey = ["watchHistoryPartialUpdate"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof watchHistoryPartialUpdate>>,
    { id: number; data: NonReadonly<PatchedUserWatchHistory> }
  > = (props) => {
    const { id, data } = props ?? {};

    return watchHistoryPartialUpdate(id, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type WatchHistoryPartialUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof watchHistoryPartialUpdate>>
>;
export type WatchHistoryPartialUpdateMutationBody =
  NonReadonly<PatchedUserWatchHistory>;
export type WatchHistoryPartialUpdateMutationError = unknown;

/**
 * @summary Update User Watch History
 */
export const useWatchHistoryPartialUpdate = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof watchHistoryPartialUpdate>>,
    TError,
    { id: number; data: NonReadonly<PatchedUserWatchHistory> },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof watchHistoryPartialUpdate>>,
  TError,
  { id: number; data: NonReadonly<PatchedUserWatchHistory> },
  TContext
> => {
  const mutationOptions = getWatchHistoryPartialUpdateMutationOptions(options);

  return useMutation(mutationOptions);
};
